# 锁

## 锁问题
通过锁机制实现了事物的隔离性要求，使事物可以并发地工作。但在并发情况下，多个事物同时对同一事物进行操作，会带来以下几种并发不一致问题：

### 1.丢失更新
即一个事务的更新操作会被另一个事务的更新操作所覆盖。例如；事务T1先将行记录r更新为v1，事务T2再将记录r更新为v2（当前两事务均为提交）。随后事务T1先提交，事务T2后提交。则最终记录r即为v2，事务T2的修改覆盖了事务T1的修改。

### 2.脏读
要理解脏读，首先要理解脏数据。

脏数据是指事物对缓冲池中行记录的修改，并且还没有提交(commit)。(它和脏页不同，后者是在缓冲池中已经修改，但还没有刷新到硬盘中的页)

脏读指的是在不同的事物下，**当前事务可以读到另外一个事物未提交的数据**。

例如：事物1修改了数据但并未提交，事物2随后读取了这个数据，之后如果事物1回滚了此次修改，事物2读到的就是不正确的数据。

### 3.不可重复读
不可重复读是指在一个事物内多次读取同一数据集合，在这个事物还没有结束时，另一个事物也访问了该数据集合并做了一些修改。因此，由于第二个事物的修改，第一个事物两次读取到的数据可能是不一致的。

例如：事物1先读取一次数据，之后事物2对数据进行了修改并提交，这样事物1再次读取这个数据时，读取结果就和第一次不同。

不可重复读和脏读的区别：
* 脏读读到的是未提交的数据，不可重复读读到的是已提交的数据
* 脏读违反了数据库事物的隔离性，不可重复读违反了数据库事物的一致性。

### 4.幻读
幻读和不和重复读类似，是指当一个事务T1读取了几行数据后，另一个并发事务T2插入了一些数据，因此在之后的查询中，事务T1就会发现多了一些原本不存在的记录。

幻读和不可重复读的区别：
* 幻读的关注点在于增删，比如多次读取一条记录发现记录增多或减少了。
* 不可重复读的关注点在于修改，比如多次读取一条记录发现其中某些列的值被修改。

产生并发不一致问题的主要原因是破坏了事务的隔离性，数据库系统提供了多种事务的隔离级别供用户解决并发一致性问题。