# 锁
数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。


## 锁的粒度
锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。但锁的各种操作(获取锁、释放锁、检查锁状态)都会增加系统开销。因此锁的粒度越小，系统开销就越大。因此在选择锁的粒度时，需要在锁开销和并发程度做平衡。

MySQL数据库根据锁的粒度把锁分为表级锁和行级锁:
* 表级锁：对当前操作的整张表加锁。锁的粒度大，系统开销小，加锁快，不会出现死锁。但发生锁冲突的概率高，并发程度低。
* 行级锁：只对当前操作的行进行枷锁。锁的粒度小，系统开销大，加锁慢，会出现死锁。但能大大减少数据库操作的冲突，并发度高。


InnoDB支持行级锁和表级锁，默认为行级锁。而MyISAM存储引擎支持表级锁。

## 锁的类型
InnoDB实现了以下两种标准的行级锁：
* 共享锁（S Lock）：也叫读锁。如果一个事务获得数据对象A的S锁，就可以对A进行读操作，但是不能进行写操作，加锁期间其他事务也可以获得A的S锁并读取它。但任何事务都不能获取数据上的X锁，直到A已释放所有共享锁。
* 排他锁（X Lock）：也叫写锁。如果一个事务获得数据对象A的X锁，就可以对A进行读和写操作。加X锁期间其他事务不能对A加任何锁，因此叫排他锁。

锁的兼容性可以理解为：同一个数据对象可否同时获得两个不同的锁：

![](锁的类型.jpg)

为了支持在更细粒度上进行加锁，InnoDB支持意向锁。意向锁将锁定的对象分为多个层次。如果需要对页上的记录r进行上X锁，那么分别需要对数据库A、表、页上意向锁IX，最后对记录r上X锁。

当一个事务需要给自己需要的某个资源加锁的时候，如果遇到一个共享锁正锁定着自己需要的资源的时候，自己可以再加一个共享锁，不过不能加排他锁。但是，如果遇到自己需要锁定的资源已经被一个排他锁占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。

而意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。

意向锁是一种表锁，分为如下两种：
* 意向共享锁（IS Lock）：表示事务准备给数据行记入共享锁，一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁。
* 意向共享锁（IX Lock）：表示事务准备给数据行加入排他锁，一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

注意：
* 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁。
* IX，IS是表级锁，不会和行级的X，S锁发生冲突，只会和表级的X，S发生冲突。

## 锁问题
通过锁机制实现了事物的隔离性要求，使事物可以并发地工作。但在并发情况下，多个事物同时对同一事物进行操作，会带来以下几种并发不一致问题：

### 1.丢失更新
即一个事务的更新操作会被另一个事务的更新操作所覆盖。例如；事务T1先将行记录r更新为v1，事务T2再将记录r更新为v2（当前两事务均为提交）。随后事务T1先提交，事务T2后提交。则最终记录r即为v2，事务T2的修改覆盖了事务T1的修改。

### 2.脏读
要理解脏读，首先要理解脏数据。

脏数据是指事物对缓冲池中行记录的修改，并且还没有提交(commit)。(它和脏页不同，后者是在缓冲池中已经修改，但还没有刷新到硬盘中的页)

脏读指的是在不同的事物下，**当前事务可以读到另外一个事物未提交的数据**。

例如：事物1修改了数据但并未提交，事物2随后读取了这个数据，之后如果事物1回滚了此次修改，事物2读到的就是不正确的数据。

### 3.不可重复读
不可重复读是指在一个事物内多次读取同一数据集合，在这个事物还没有结束时，另一个事物也访问了该数据集合并做了一些修改。因此，由于第二个事物的修改，第一个事物两次读取到的数据可能是不一致的。

例如：事物1先读取一次数据，之后事物2对数据进行了修改并提交，这样事物1再次读取这个数据时，读取结果就和第一次不同。

不可重复读和脏读的区别：
* 脏读读到的是未提交的数据，不可重复读读到的是已提交的数据
* 脏读违反了数据库事物的隔离性，不可重复读违反了数据库事物的一致性。

### 4.幻读
幻读和不和重复读类似，是指当一个事务T1读取了几行数据后，另一个并发事务T2插入了一些数据，因此在之后的查询中，事务T1就会发现多了一些原本不存在的记录。

幻读和不可重复读的区别：
* 幻读的关注点在于增删，比如多次读取一条记录发现记录增多或减少了。
* 不可重复读的关注点在于修改，比如多次读取一条记录发现其中某些列的值被修改。

产生并发不一致问题的主要原因是破坏了事务的隔离性，数据库系统提供了多种事务的隔离级别供用户解决并发一致性问题。

## 参考
[MySQL锁机制](https://blog.csdn.net/qq_34337272/article/details/80611486)