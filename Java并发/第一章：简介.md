# 第一章：简介
每个线程都有各自的程序计数器、栈以及局部变量等。在同一个程序中的多个线程也可以被同时调度到多个CPU上运行。

线程也被称为轻量级进程。在大多数操作系统中，线程都是最基本的调度单位。但由于同一个进程中的所有线程都将共享进程的内存地址空间，因此这些线程都能访问相同的变量并在同一个堆上分配对象。如果没有明确的同步机制来协同对共享数据的访问，那么当一个线程正在使用某个变量时，另一个线程可能同时访问这个变量，造成不可预测的后果。

## 第二章：线程安全性
要编写线程安全的代码，其核心在于要对状态的访问操作进行管理，特别是对共享的和可变的状态的访问。  
注：对象的状态是指存储在状态变量(实例域或静态域)中的数据。共享意味着该变量可以由多个线程同时访问，可变意味着变量的值在其生命周期内可以发生变化。

要使得对象是线程安全的，需要采用同步机制来协同对对象可变状态的访问。当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。

**线程安全性**：当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类就能表现出正确的行为，那么就称这个类是线程安全的。

**无状态的对象**：一个对象如果既不包含任何域，也不包含任何对其他类中域的引用。计算过程中的临时状态仅存在于线程栈上的局部变量中，并且只能由正在执行的线程访问。那么这个对象是无状态的。

**无状态的对象一定是线程安全的**

**竞态条件（Race Condition):** 当某个计算的正确性取决于多个线程的交替执行次序时，就会发生竞态条件。本质是基于一种可能失效的观察结果来做出判断或者执行某个计算。  
两个例子：
* 先检查后执行（Check-then-Act）：比如单例模式中的懒汉模式。
* “读取-修改-写入”操作：比如count++这一句其实包含三个操作；读取count，将count加1，更新count。

要避免竞态条件，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量。

在不变性条件涉及多个变量时，各个变量之间并不是彼此独立的，而是某个变量的值会对其他变量的值产生约束。因此，当更新某一个变量时，需要在同一个原子操作中对其他变量进行更新。

### 加锁机制
**1.内置锁**  
Java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized），同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。
```java
synchronized(lock){
    //访问或修改由锁保护的共享状态
}
//lock即为方法调用所在的对象。
```

线程在进入同步代码块之前会自动获得锁，在退出同步代码块时自动释放锁。在某一时刻，最多只能有一个线程持有这种锁。

对于单例模式的懒汉模式（先检查后执行），可以通过加锁保证线程安全。在同一时刻只有一个线程能进入到getInstance()方法。
```java
public class A {
    private static A instance = null;
    public static synchronized A getInstance(){
        if(instance == null){
            instance = new A();
        }
        return instance;
    }
}
```

**2.重入**

重入：即对于同一个线程，它可以重新获得已有它占用的锁。

重入意味着获取锁的操作的粒度是线程，而不是调用

用锁来保护状态：
* 对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有一个锁，在这种情况下，我们称这个状态变量是被这个锁保护的。
* 对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。